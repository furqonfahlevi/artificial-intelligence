# -*- coding: utf-8 -*-
"""Final Genetic Algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gp6OI4bbaa9Fgaf4FwSpbt6SnT0RFdMe

<h1><b>Group 8</b></h1>
Genetic Algoritm

---

<p>Akmal Rafiid (NIM)</p>
<p>Rizqi Khoir (1301194255)</p>
<p>Muhammad Furqon Fahlevi         (1301194214)</p>

---

*   Question Link
    http://bit.ly/2Pjn6Vv

Do Analysis, design, and Implement Genetic Algorithm (GA) to computer program for finding <b>Maximum Value</b> from Formula : 
<b>h(x,y) = x^2 * (sin y2) +(x+y)</b>
with limitation : <b>-1 ≤ x ≤ 2 and -1 ≤ y ≤ 1</b>

# Lib that needed to run the program
"""

import random # lib random for randoming 0,1 as the gen
import math # lib math for counter the fitness formula

"""# Define Population"""

def Population(popSize, ChromoSize, popul):
  i = len(popul) # i == popul size
  
  while i < popSize:
    chromo = []
    j = 0
    while j < ChromoSize:
      chromo.append(random.randint(0,1)) # random gen and append it to list of chromosome
      j += 1
    popul.append(chromo) # result of the 1 i loop will append 1 chromosome to population
    i += 1

  return popul

"""# Decode Population"""

def Decode(popul):
  # -1 <= x <=2 && -1 <= y <= 1 *Formula*
  populDecoded = [] # list of decoded population will save here
  x, y = 0.0, 0.0
  i, sigma = 0, 0

  while i < len(popul):
    decoded = []
    temp = popul[i]
    z, b, a = 0, 0, 0
    while z < len(popul[i]):
      if z < len(popul[i]) / 2:
        a = a + temp[z] * 2** - (z + 1)
        sigma += 2 ** - (z + 1)
      else:
          b = b + temp[z] * 2** - (z + 1)
          z = z + 1
      z += 1
    x = -1 + (2 - (-1) / sigma) *a # Formula to get the x
    y = -1 + (1 - (-1) / sigma) *b # Formula to get the x
    decoded.append(x)
    decoded.append(y)
    populDecoded.append(decoded)
    i += 1

  return populDecoded

"""# Fitness Score Check"""

def fitnessRule(x,y): #Formula funtion that will return 1 float number

  return (x*x)*math.sin(math.sin(y*y))+(x+y)

def fitnessScore(popDecoded):
  temp, fitness = [], []
  i = 0
  
  while i < len(popDecoded):
    j, z, x, y = 0, 0, 0, 0
    temp = popDecoded[i]
    while j < len(temp):
      if j < len(temp)/2:
        x = temp[j]
      else:
        y = temp[j]
      j+=1 
    z = fitnessRule(x,y) # the result x and y will be calculated by fitnessRule and output the result of 1 float number
    fitness.append(z)
    i+=1

  return fitness

"""# Parent Selection"""

def parentSelection(fitnessResult):
  #use Turnament method, the best and the second best value will be the parent
  #this func will return int index of the parent
  parent = []
  sort = sorted(fitnessResult) #sorting ascending
  best = sort[len(sort)-1]
  secBest =  sort[len(sort)-2]

  counterIndex = 0
  for i in fitnessResult:
    if i == best or i == secBest:
      parent.append(counterIndex)
    counterIndex += 1
  # print("sort", sort)
  # print("real list", fitnessResult)

  return parent

"""# Cross Over Parent"""

def CrossOver(parent, popul):
  # len(popul) > parent
  # parent must be index
  # popul is normal list of chromo
  coResult = [] # result of the crossover

  [0,1,1,1,0,0] [0,1,1,1,0,0]

  s1 = popul[parent[0]]
  s2 = popul[parent[1]]
  coResult.append(s1[0:3] + s2[3:6]) 
  coResult.append(s2[0:3] + s1[3:6]) 
  # print("parent", s1, "--", s2)
  # print("coResult", coResult)

  return coResult

"""# Mutation"""

def mutation(coResult):
  # coResult cannot be 0
  # bit string mutation
  # flip bit(**not yet**)
  # probability = 0.01
  prob = 0.01
  mut = coResult
  i = 0
  changeCounter = 0

  while i < len(mut):
    j = 0
    while j < len(mut[i]):
      randProb = round(random.uniform(0.00, 1.00), 2)
      if randProb < float(prob):
        changeCounter += 1
        if mut[i][j] == 1:
          mut[i][j] = 0
        else:
          mut[i][j] = 1
      j += 1
    i += 1
  print("got", changeCounter, "Mutation")
  
  return mut

"""# General Replacment"""

def GeneralReplacement(popul, mutated, kidList, generation):
  # by Utilizing recursive in this func to run all untill get the highest value
  # by utilizing recursive the program will be more light-weight and can increase the running speed
  popul = []

  kidList.append(mutated[0])
  kidList.append(mutated[1])
  print("Generation", generation, "Kid =", kidList[generation], kidList[generation-1], "\n")
  popul.append(mutated[0])
  popul.append(mutated[1])
  popul = Population(10, 6, popul)

  if generation >= 10:
    if kidList[generation] == kidList[generation-10] and kidList[generation-1] == kidList[generation-10-1]:
      print("=======================================================================================")
      print("Highest found at generation", generation, ", with kid =", kidList[generation], kidList[generation-1])
      print("generation", generation-10,"("+str(generation)+"-10"+")", "=", kidList[generation-10], kidList[generation-10-1])
    else:
      generation += 1
      GeneralReplacement(popul, mutation(CrossOver(parentSelection(fitnessScore(Decode(popul))), popul)), kidList, generation)
  else:
    generation += 1
    GeneralReplacement(popul, mutation(CrossOver(parentSelection(fitnessScore(Decode(popul))), popul)), kidList, generation)

"""# Main Program"""

# after i run it over 10times, i always get runtime 0-1 second, so i think its fast enough

popul = []
popul = Population(10, 6, popul)
print("popul gen 0 =", popul, "\n")
kidList = []
generation = 1

GeneralReplacement(popul, mutation(CrossOver(parentSelection(fitnessScore(Decode(popul))), popul)), kidList, generation)